matrix drop _all
scalar drop _all

// This file does the values and variances, drawing on output of analysis_redo_tables and  analysis_lcfs_.   It should be read with reference to appendices D to G of the paper. Equation 12 sets out the expression for the variance of life-tiem utilityw which we evaluate. There are three components to it requiring i) the variance of the number of life years in each band, ii) the variance of the proportion of people in good health and iii) the variance of the vector of instaneous utility in each age band. These are evaluated separately for men and women, and  the covariance between them is also required when evaluating the variance of the mean of well-being of women and men. This latter component arises because the measures of well-being of the two sexes rely on the same consumptino-based figures for men and women. The other components are assumed independent of each other.  //

clear all
set more off
set maxvar 32000, perm

global output "P:/Working/KlemowMeasure"
global matrix "P:/Working/KlemowMeasure/matrices"
	scalar drop _all
do "$output/matout"
do "$output/matin"
*read in weight put on years of poor health
matin healthwt using "$matrix/healthwt"
scalar healthw=healthwt[1,1]
use  "$output/ltlameans_exog_var21Jul23", clear
gen q="Kings Lynn and West Norfolk" if _n==168
replace ltla19nm=q if _n==168
*to deal with apostrophe which causes trouble in printing
flist ltla19nm in 167/169
gen const=1
mkmat gor, mat(gor)
* these are the administative variables
*Put together the exogenous variables that are used to compute fitted consumption. These are ltla averages generated by the collapse command in analysis_redo_tables22Jun23.do. Their contribution to variance 
*comes from the variances of the mixed model parameters in Vcons Vlmen and Vlwomen
mkmat lnetinc lelect_avg lhp_mean const, mat(X)
* read in alpham- the share of private consumption in the total
matin alpham using "$matrix/alpham"
scalar alpha=alpham[1,1]
* read in the parameters (bcons) and their variance matrix (Vcons) of the consumption model. Read in similar figures for the time use of men and women. 
*Then read in the invariant components of the utility function associated with labour time for men and women (utilm and utilw), the common component from consumption and the population weights 
matin Vcons using "$matrix/Vcons"
matin bcons using "$matrix/bcons"
matin Vlmen using "$matrix/Vlmen"
matin blmen using "$matrix/blmen"
matin Vlwomen using "$matrix/Vlwomen"
matin blwomen using "$matrix/blwomen"
matin utilm using "$matrix/utilm"
matin utilw using "$matrix/utilw"
matin utilc using "$matrix/utilcommon"
matin adultwt using "$matrix/adultwt"
****gen work2mw=14.2*((1-leisuremw)^2)/2 *relation betwen leisure and utility term

*predict flmree1 flmree2 flmree3 if lprivconseq==. & sex==1., reses
*	predict flfree1 flfree2 flfree3 if lprivconseq==. & sex==2., reses
* give standard errors of age, region and ltla effects
*fcree1 fcree2 fcree3 are standard errors of age, gor and ltla effects in consumption from analysis_redo_tables
	*flmree1 flmree2 flmree3  does labour residuals of age, gor and ltla effects for men
	*flfree1 flfree2 flfree3 does labour residuals of age, gor and ltla effects for women
egen qcree1=mean(fcree1)
scalar se1=exp(bcons[1,5])
scalar se2=exp(bcons[1,6])
scalar se3=exp(bcons[1,7])
scalar list se1 se2 se3
replace fcree1=qcree1 if fcree1==.
replace fcree2=se2 if fcree2==.
replace fcree3=se3 if fcree3==.
*PUT IN MEAN OF STANDARD ERRORS FOR fcree1 SINCE same age effects are used everywhere
*PUT IN sd of random effects for region and ltla19cd since these are the uninformed variances
mkmat fcree1 fcree2 fcree3, matrix(fcr)
mkmat flmree1 flmree2 flmree3, matrix(flmr)
mkmat flfree1 flfree2 flfree3, matrix(flfr)
mat Vcons=Vcons[1..4,1..4]
mat Vlmen=Vlmen[1..4,1..4]
mat Vlwomen=Vlwomen[1..4,1..4]
*Vcons Vlmen Vlwomen are the variances of the parameters. Calculate the variances of the fitted values and adds in the variances of the random terms (age, region and ltla). 
*do this for men, wometn and common terms
forvalues rr=1/315{
	mat x=X[`rr',1..4]
	mat vconsf`rr'=x*Vcons*x'+(fcr[`rr',1])^2+(fcr[`rr',2])^2+(fcr[`rr',3])^2
	*Then evaluate variance from this and add in variance from random effects. See equations 30 and 31. These are used at line 189
	mat vlmenf`rr'=x*Vlmen*x'+(flmr[`rr',1])^2+(flmr[`rr',2])^2+(flmr[`rr',3])^2
	mat vlwomenf`rr'=x*Vlwomen*x'+(flfr[`rr',1])^2+(flfr[`rr',2])^2+(flfr[`rr',3])^2
	mat cvconsf`rr'=x*Vcons*x'+(fcr[`rr',2])^2+(fcr[`rr',3])^2
	mat cvlmenf`rr'=x*Vlmen*x'+(flmr[`rr',2])^2+(flmr[`rr',3])^2
	mat cvlwomenf`rr'=x*Vlwomen*x'+(flmr[`rr',2])^2+(flmr[`rr',3])^2
}

*mat vconsfit=Vcons*X
*mat list vconsfit
*******************************
cap drop utlacd
destring utla19cd, ignore("E") gen(utlacd)
mkmat utlacd
mat utlacode=J(315,1,1)
scalar s1=1
*Here I create a mapping from utla to ltla
forvalues j=2/315{
	scalar c1=utlacd[`j',1]
	scalar c2=utlacd[`j'-1,1]
	if c1==c2{
		mat utlacode[`j',1]=s1
	}
	if c1~=c2{
		scalar s1=s1+1
mat utlacode[`j',1]=s1
	}
}
********************************
*mkmat utlacod, matrix(utlacode) TAKE THIS LINE OUT 3Apr 2023
*Count is not used so this part of the code down to mat count is redundant
mat count=J(315,1,1)
mat count[1,1]=1
forvalues k=2/315{
	scalar s1=utlacode[`k',1]
	scalar s2=utlacode[`k'-1,1]
	if s1==s2{
mat count[`k',1]= count[`k'-1,1]+1 
}
}
mat count=(utlacode, count)
*count is not used!!!
*this reads in the variances for life expectancy and hea;thy life expectancy for men and women
forvalues rr=1/315{
	matin VV`rr' using "$matrix/VV`rr'"
	matin VH`rr' using "$matrix/VH`rr'"
matin VVw`rr' using "$matrix/VVw`rr'"
	matin VHw`rr' using "$matrix/VHw`rr'"

	}
	*Note that in earlier programmes VV and VH were on utla basis. Now on LTLA basis
*so simply relable matrices to fit the rest of the programme. 
	*AVV AVH and AVVw AVHw	contain the variances recoded to LTLAs

	forvalues rs=1/315{
*		forvalues rt=1/315{
*			if utlacode[`rs',1]==`rt'{
				mat AVV`rs'=VV`rs'
					mat AVH`rs'=VH`rs'
									mat AVVw`rs'=VVw`rs'
					mat AVHw`rs'=VHw`rs'
*			}
*	}
	}
*READ IN LIFE TABLE DATA. Lx, Lxw are life years and HP and HPw are prevalance of good health
*LX s number of life years in each band. lx is number of survivors at the start of each age band and HP is the prevalence of good health. "w" indicates variables for women. 
matin Lx using "$matrix/Lx"
matin lx using "$matrix/lxx"
matin HP using "$matrix/HP"
matin lxw using "$matrix/lxxw"
matin Lxw using "$matrix/Lxw"
matin HPw using "$matrix/HPw"
forvalues rr==1/315{
	*some of these need transposing
*	scalar cv=utlacode[`rr',1]
	scalar cv=`rr'
	mat HPv`rr'=HP[cv,1..20]
	mat Lxv`rr'=Lx[1..20,cv]
	mat Lxv`rr'=Lxv`rr''
	mat lxv`rr'=lx[1..20,cv]
	mat lxv`rr'=lxv`rr''
	mat HPvw`rr'=HPw[cv,1..20]
	mat Lxvw`rr'=Lxw[1..20,cv]
	mat Lxvw`rr'=Lxvw`rr''
	mat lxvw`rr'=lxw[1..20,cv]
	mat lxvw`rr'=lxvw`rr''
*	mat HPvw`rr'=HPvw`rr''
	
}
*does ltla values from here to **&
*matin utilm using "$matrix/utilm"
*matin utilw using "$matrix/utilw"
*matin utilcommon using "$matrix/utilcommon"
mat w=[0,0,0,0,0]
mat u=J(315,2,0)
mat uw=u
mat uh=u
mat uhw=u
mat uzw=u
mat ub=u
mat uhb=u
mat Vub=u
mat Vuw=u
mat Vu=u
mat VC=J(20,20,0)
mat VLF=VC
mat VLM=VC
mat le=J(315,2,0)
mat lew=le
mat ue=J(315,2,1)
mat ee=J(1,15,1)
*PUT TOGETHER VARIANCE COMPONENTS OF UTILITY
*note that we start with the sixth entry in the demographic statistics. The first five relate to children aged under twenty.
*for each LTLA we construct VC which is the variance of the consumption term for each age group, VLF and VLM, which are the variances of the leisure terms for women and men. The offdiagonal terms are evaluated first. These do not include the variances of the age term because we assume that the age random effects are independent of each other. See appendix D3. Equations 28 and 29.
forvalues rr=1/315{
	forvalues ma=6/20{
		scalar ma=`ma'
			forvalues mb=6/`ma'{
				scalar mb=`mb'
mat VC[`ma',`mb']=alpha^2*cvconsf`rr'
mat VLF[`ma',`mb']=cvlwomenf`rr'
mat VLM[`ma',`mb']=cvlmenf`rr'			
mat VC[`mb',`ma']=alpha^2*cvconsf`rr'
mat VLF[`mb',`ma']=cvlwomenf`rr'
mat VLM[`mb',`ma']=cvlmenf`rr'			

	if ma==mb{
mat VC[`ma',`mb']=alpha^2*vconsf`rr'
mat VLF[`ma',`mb']=vlwomenf`rr'
mat VLM[`ma',`mb']=vlmenf`rr'			
		}
	}	
	}
*men no health
	mat Hpr=0.0*HPv`rr'+1.0*J(1,20,1)
		*utility is evalauted from the intanstaneous utility figure read in multiplied by the health factor and the number of life years in the age band 
	*remember rr indexes LTLA
mat u[`rr',1]=[w,utilm[`rr',1...]]*diag(Hpr)*Lxv`rr''
*health adjusted life expectancy is given sy summing life years in each band multiplied by health factor. See equation 12. 
mat le[`rr',1]=[w,ee]*diag(Hpr)*Lxv`rr''
mat Mxv=0*Lxv`rr'
****!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
mat Mxv[1,20]=Lxv`rr'[1,20]
scalar mxv=Mxv[1,20]
forvalues j=19(-1)6{
*scalar jj=`j'+1
mat Mxv[1,`j']=mxv+Lxv`rr'[1,`j']
scalar mxv=Mxv[1,`j']
}
*AVV is variance of lfe years in each band matrix
*first line of vm is impact of life years uncerainty on life-time utility. w ensures no weight is given to life years of children. See equation 13 with health term there set to unit matrix
mat vm=[w,utilm[`rr',1...]]*AVV`rr'*[w,utilm[`rr',1...]]'
*second line is variance arising from model uncertainty
mat vm=vm+Lxv`rr'*(VC+VLM)*Lxv`rr''
*VU is standard deviation
mat Vu[`rr',1]=sqrt(vm[1,1])
*lbd is variance of life expectancy
mat lbd`rr'=[w,ee]*AVV`rr'*[w,ee]'
*Same for women with no health effect
mat Hprw=0.0*HPvw`rr'+1.0*J(1,20,1)            
mat lew[`rr',1]=[w,ee]*diag(Hprw)*Lxvw`rr''
mat lbdw`rr'=[w,ee]*AVVw`rr'*[w,ee]'
mat uw[`rr',1]=[w,utilw[`rr',1...]]*diag(Hprw)*Lxvw`rr''
mat vf=[w,utilw[`rr',1...]]*AVVw`rr'*[w,utilw[`rr',1...]]'
mat vf=vf+Lxvw`rr'*(VC+VLF)*Lxvw`rr''
mat Vuw[`rr',1]=sqrt(vf[1,1])
*and the average of men and women. This has to allow for the coviarnce effect arisin because the consumption model is common to both. See appendix E
mat ub[`rr',1]=(u[`rr',1]+uw[`rr',1])/2
*see equation 38
mat vb=(vf+vm)+Lxvw`rr'*diag(Hprw)*(VC)*diag(Hpr)*Lxv`rr''
mat vb=vb+Lxv`rr'*diag(Hpr)*(VC)*diag(Hprw)*Lxvw`rr''
mat Vub[`rr',1]=sqrt(vb[1,1]/4)
*Now I do the same for men but with a health effect included. This requres the  term in H in equation 12 in addition to the other terms
mat Hpr=(1-healthw)*HPv`rr'+healthw*J(1,20,1)
mat le[`rr',2]=[w,ee]*diag(Hpr)*Lxv`rr''
mat u[`rr',2]=[w,utilm[`rr',1...]]*diag(Hpr)*Lxv`rr''
*see equation 13
mat vm=[w,utilm[`rr',1...]]*diag(Hpr)*AVV`rr'*diag(Hpr)*[w,utilm[`rr',1...]]'
mat vm=vm+((1-healthw)^2)*[w,utilm[`rr',1...]]*diag(Lxv`rr')*AVH`rr'*diag(Lxv`rr')*[w,utilm[`rr',1...]]'
mat vm=vm+Lxv`rr'*diag(Hpr)*(VC+VLM)*diag(Hpr)*Lxv`rr''
mat Vu[`rr',2]=sqrt(vm[1,1])
mat lbdh`rr'=[w,ee]*(diag(Hpr)*AVV`rr'*diag(Hpr)+diag(Lxv`rr')*AVH`rr'*diag(Lxv`rr'))*[w,ee]'
*women with health effect
mat Hprw=(1-healthw)*HPvw`rr'+healthw*J(1,20,1)
mat lew[`rr',2]=[w,ee]*diag(Hprw)*Lxvw`rr''

mat uw[`rr',2]=[w,utilw[`rr',1...]]*diag(Hprw)*Lxvw`rr''
mat vf=[w,utilw[`rr',1...]]*diag(Hprw)*AVVw`rr'*diag(Hprw)*[w,utilw[`rr',1...]]'
mat vf=vf+((1-healthw)^2)*[w,utilw[`rr',1...]]*diag(Lxvw`rr')*AVHw`rr'*diag(Lxvw`rr')*[w,utilw[`rr',1...]]'
mat vf=vf+Lxvw`rr'*diag(Hprw)*(VC+VLF)*diag(Hprw)*Lxvw`rr''
mat Vuw[`rr',2]=sqrt(vf[1,1])
mat lbdwh`rr'=[w,ee]*(diag(Hprw)*AVVw`rr'*diag(Hprw)+diag(Lxvw`rr')*AVHw`rr'*diag(Lxvw`rr'))*[w,ee]'
*both with health
mat ub[`rr',2]=(u[`rr',2]+uw[`rr',2])/2
* second columns give welfare adjusted for healthy life years 
*do variances here and remember to take square root
*CHECK THAT 0.04 IS NOT ALREADY ON BOARD
mat vb=(vf+vm)+Lxvw`rr'*diag(Hprw)*(VC)*diag(Hpr)*Lxv`rr''
mat vb=vb+Lxv`rr'*diag(Hpr)*(VC)*diag(Hprw)*Lxvw`rr''
mat Vub[`rr',2]=sqrt(vb[1,1]/4)
*REMEMBER TO DIVIDE BY 4
*mat vu=[w,utilm[`rr',1...]]*AVH`rr'*[w,utilm[`rr',1...]]'
*mat Vu[`rr',2]=sqrt(vu[1,1])
}
*svmat turns these matrices into variables. Each column is given a separate variable name, ending in the number of the column.
svmat u
svmat utilm
svmat uw
svmat utilw
svmat ub
svmat Vub
svmat Vu
svmat Vuw
flist ltla19nm u1 u2 uw1 uw2 Vu2 Vuw2
sort ub1
gen rb1=_n
sort ub2
gen rb2=_n
*Now do variance of population-weighted average for England
sort ltla19cd
*put back in code order so that adultwt works
flist ltla19nm  ub1 ub2 Vub1 Vub2 
table ltla19nm, c(mean rb1 mean ub1 mean Vub1 )
table ltla19nm, c(mean rb2  mean ub2 mean Vub2)
*now calculate variables lex and ueng for England using weights given by the number of adults in each LTLA
 mat lex=adultwt'*(le+lew)/2
 *calculate weighted average for England
mat ueng=adultwt'*ub
scalar ubl=ueng[1,1]
scalar ubh=ueng[1,2]
scalar lexl=lex[1,1]
scalar lexh=lex[1,2]
scalar list
*scalar alpha=0.8. Read in from matrix alpham instead 
*gives relative measure following equaltion 5 of the paper
mat lambdal=(ub[1...,1]-ubl*ue[1...,1])/(alpha*lexl)
mat lambdah=(ub[1...,2]-ubh*ue[1...,1])/(alpha*lexh)
*mat list lambdal
svmat lambdal, names(lambdal)
svmat lambdah, names(lambdah)
mat leb=(le+lew)/2
svmat leb
ren leb1 lebl
ren leb2 lebh
mkmat lebl
mkmat lebh
**** This implements appendix G
*do both health states by varying healthw 0.75 for health adjustment 1 for no health adjustment
*note that appendix G show show the variance of the relative measure is calculated and then discusses the component parts.
*In this programme I have to evaluate the component parts shown in equations 48 to 51 before putting them together as shown in equations 47 and 46
forvalues q=1/2{
if `q'==1{
	scalar healthw=1
}
if `q'==2{
*	gen health weight from matrix
	scalar healthw=healthwt[1,1]
}
mat COVUU=J(315,315,0)
mat COVDD=COVUU
mat COVUD=COVUU
mat Covuu=J(20,20,1)
mat Covup=J(20,20,1)
mat eed=diag(J(20,1,1))
mat ee=(J(20,1,1))
* this will be set to the covariance matrix of utility by age
forvalues k=1/315{
mat Hprk=(1-healthw)*HPv`k'+healthw*J(1,20,1)
mat Hprwk=(1-healthw)*HPvw`k'+healthw*J(1,20,1)
mat x=X[`k',1..4]
		*evaluate covariance matrix of utility by age group both when k=p and when k!=p
		*1 is age term 2 is region term 3 is ltla term

	forvalues p=1/`k'{
	mat Covumm=J(20,20,1)
 mat Covuff=J(20,20,1)
 mat Covumf=J(20,20,1)
 mat Covufm=Covumf
		scalar del=0
				*del is indicator which identifies when LTLAs in row and column match
		if `p'==`k'{
			scalar del=1
		}
		scalar gor1=gor[`p',1]
		scalar gor2=gor[`k',1]
		scalar delgov=0
		if gor1==gor2{
		scalar delgov=1 
		}
*delgov is indicator for when both LTLAs are from the same gor.

		mat y=X[`p',1..4]
*cv is covariance across age

*fcrs are standard deviations which need to be squared to give variances
*evaluate the first term in each of equations 48-51
	mat vconsfkp=x*Vcons*y'+(fcr[`k',1])^2+delgov*(fcr[`k',2])^2+del*(fcr[`k',3])^2
	mat vlmenfkp=x*Vlmen*y'+(flmr[`k',1])^2+delgov*(flmr[`k',2])^2+del*(flmr[`k',3])^2
	mat vlwomenfkp=x*Vlwomen*y'+(flfr[`k',1])^2+delgov*(flfr[`k',2])^2+del*(flfr[`k',3])^2
*mat vlconsboth=x*Vcons*y'+(fcr[`k',1])^2+delgov*(fcr[`k',2])^2+del*(fcr[`k',3])^2)
	mat cvconsfkp=x*Vcons*y'+delgov*(fcr[`k',2])^2 +del*(fcr[`k',3])^2
	mat cvlmenfkp=x*Vlmen*y'+delgov*(flmr[`k',2])^2 +del*(flmr[`k',3])^2
	mat cvlwomenfkp=x*Vlwomen*y'+delgov*(flmr[`k',2])^2+del*(flmr[`k',3])^2
*Working out terms
	scalar vcfkp=vconsfkp[1,1]
	scalar vmenfkp=vlmenfkp[1,1]
	scalar vwomenfkp=vlwomenfkp[1,1]
	scalar cvcofkp=cvconsfkp[1,1]
	scalar clmenfkp=cvlmenfkp[1,1]
	scalar clwmenfkp=cvlwomenfkp[1,1]
	*evaluate Covumm etc. See equations 48 to 51 
	mat Covumm=alpha^2*cvconsfkp*Covumm
	mat Covuff=alpha^2*cvconsfkp*Covuff
	mat Covumf=alpha^2*cvconsfkp*Covumf
	mat Covufm=alpha^2*cvconsfkp*Covufm
	forvalues j=1/20{
	mat Covumm[`j',`j']=alpha^2*vcfkp+vmenfkp
	mat Covuff[`j',`j']=alpha^2*vcfkp+vwomenfkp
	mat Covumf[`j',`j']=alpha^2*vcfkp
	mat Covufm[`j',`j']=alpha^2*vcfkp
	}
* also need to think about covariance between men and women in utility function

		************
*note that healthw is weight given to years in poor health
		mat Hprp=(1-healthw)*HPv`p'+healthw*J(1,20,1)
mat Hprwp=(1-healthw)*HPvw`p'+healthw*J(1,20,1)
*s is used to work out COVUU See equation 46 and first four terms of equation 47
	mat  s=0.25*(Lxv`k'*diag(Hprk)*Covumm*diag(Hprp)*Lxv`p'') /*mm*/
	mat s=s+0.25*(Lxvw`k'*diag(Hprwk)*Covuff*diag(Hprwp)*Lxvw`p'') /*ff*/
mat s=s+0.25*(Lxv`k'*diag(Hprk)*Covumf*diag(Hprwp)*Lxvw`p'') /*mf. */
mat s=s+0.25*(Lxvw`k'*diag(Hprwk)*Covufm*diag(Hprp)*Lxv`p'') /*fm. */
*NEED TO SORT OUT BELOW HERE
	scalar delp=utlacode[`p',1]
scalar delk=utlacode[`k',1]
*take out utlacode effect since variances assumed to be independent across ltlas given new mortality data
scalar delp=`p'
scalar delk=`k'
 if delp==delk{
 	*note mm and mf only. Demographic stats for men and women are independent
		*w is 5 zeroes because util starts only in sixth age band. See line 166
mat ccwk=[w,utilw[`k',1...]]
mat cck=[w,utilm[`k',1...]]
mat ccwp=[w,utilw[`p',1...]]
mat ccp=[w,utilm[`p',1...]]

*note that for demographic stuff k values and p values are equal but utility values differ. DO with health weights
*COVUU is covaraince matrix arising from utility terms. Last two terms of equation 47 in four steps here. Also see equations 48-51.
	mat s=s+0.25*Lxvw`k'*diag(ccwk)*AVHw`k'*diag(ccwp)*Lxvw`k''*(1-healthw)^2
	mat s=s+0.25*Lxv`k'*diag(cck)*AVH`k'*diag(ccp)*Lxv`k''*(1-healthw)^2
	mat s=s+0.25*Hprwp*diag(ccwk)*AVVw`k'*diag(ccwp)*Hprwp'
	mat s=s+0.25*Hprp*diag(cck)*AVV`k'*diag(ccp)*Hprp'
*now do variance of demographic terms for second term. As before but with diag matrices instead of 
*COVDD is covariance matrix of D Equation 53
	mat t=0.25*Lxvw`k'*diag(ee)*AVHw`k'*diag(ee)*Lxvw`k''*(1-healthw)^2
	mat t=t+0.25*Lxv`k'*diag(ee)*AVH`k'*diag(ee)*Lxv`k''*(1-healthw)^2
	mat t=t+0.25*Hprwp*diag(ee)*AVVw`k'*diag(ee)*Hprwp'
	mat t=t+0.25*Hprp*diag(ee)*AVV`k'*diag(ee)*Hprp'

*COVDD is the covariance matrix of D. D_k is the average of men's and women's life expectancy in small area k
*COVUU is the covariance matrix of U. U_k is the average of men's and women's life-tiem utility in small area k	
	mat COVDD[`k',`p']=t
	mat COVDD[`p',`k']=t
	
	
 }
 *
	mat COVUU[`k',`p']=s
	mat COVUU[`p',`k']=s
	}
	}
cap mat drop ADULT
	forvalues k=1/315{
	    mat ADULT=nullmat(ADULT)\adultwt'
     forvalues p=1/315{
	     mat u=0
* now evaluate covariance. Note that this is not symmetric so it is necessary to go through all values
	scalar delp=utlacode[`p',1]
scalar delk=utlacode[`k',1]
*take out utlacode effect since variances assumed to be independent across ltlas given new mortality data
scalar delp=`p'
scalar delk=`k'
if delp==delk{
mat ccwk=[w,utilw[`k',1...]]     
mat cck=[w,utilm[`k',1...]]

mat lbm=0.5*diag(Lxv`k')*AVH`k'*diag(Lxv`k'')*(1-healthw)^2+0.5*diag(Hprp)*AVV`k'*diag(Hprp')
mat lbf=0.5*diag(Lxvw`k')*AVHw`k'*diag(Lxvw`k'')*(1-healthw)^2+0.5*diag(Hprwp)*AVVw`k'*diag(Hprwp')
mat u=(ccwk*lbf+cck*lbm)*ee
* u gives the covariance between the average of men's and women's life-time utility and the average of their life epxectancy. COVUD is the covariance matrix.Equation 54 
mat COVUD[`k',`p']=u
 }	     
	 }
 }
 *EVALUATE VARIANCES FOR POP-WEIGHTED AVERAGE
mat COVUNALPHAD=COVUD*alpha*adultwt
*equation 56
mat COVUENGALPHAD=adultwt'*COVUNALPHAD
*equation 57
mat COVUUREL=(I(315)-ADULT)*COVUU*(I(315)-ADULT')
mat uu=J(315,1,0)
mat dd=uu
mat dsd=dd
mat u=uu
forvalues k=1/315{
mat	uu[`k',1]=COVUUREL[`k',`k']
mat	dd[`k',1]=COVDD[`k',`k']
mat dsd[`k',1]=sqrt(dd[`k',1])
*dsd is s.e. of le or health-adjusted le OR WILL BE
mat	u[`k',1]=COVUU[`k',`k']

}
mat wtCOVDD=adultwt'*COVDD*adultwt
mat wtCOVUD=alpha*(I(315)-ADULT)*COVUD*adultwt
*gives some negative values. CHECK THIS
mat ubeng=(I(315)-ADULT)*ub
mat leb=(le+lew)/2
mat leeng=adultwt'*leb
mat leeng2=leeng
mat ubeng2=ubeng
mat leeng2[1,1]=leeng[1,1]*leeng[1,1]
mat leeng2[1,2]=leeng[1,2]*leeng[1,2]
*with health adjustment in column 2
forvalues k=1/315{
mat ubeng2[`k',1]	=ubeng[`k',1]*ubeng[`k',1]
mat ubeng2[`k',2]	=ubeng[`k',2]*ubeng[`k',2]
*square of u-ueng	
}
mat vlambda=0*uu
mat vvlambda=0*uu
forvalues k=1/315{
	scalar lb=ubeng2[`k',`q']/(alpha^2*leeng2[1,`q'])
mat	vvlambda[`k',1]=lb*(uu[`k',1]/ubeng2[`k',`q']+alpha^2*wtCOVDD/(alpha^2*leeng2[1,`q'])-/*
	*/2*wtCOVUD[`k',1]/(alpha*leeng[1,`q']*ubeng[`k',`q']))
		*expression for the variance of the relative measure in equation 46
	mat	vlambda[`k',1]=sqrt(vvlambda[`k',1])
}
scalar list lb
mat vlambda=vlambda'
if `q'==1{
mat lambdal=lambdal'\vlambda
mat list lambdal
mat lebl=lebl,dsd
}
scalar list lb
if `q'==2{
mat lambdah=lambdah'\vlambda
mat list lambdah
	mat lebh=lebh,dsd
}
*gives covariance matrix of utilities less england's utility
*adultwt is weighting matrix
*CHECK SORTING LINE 242
}
cap drop lambdah1
cap drop lambdal1
*lambdal col 1 is measure of relative well-being. lambdal col 2 is standard error- no health effect. lambdah is same with health effect. 
*lebl col 1 is life expectancy lebl col 2 is standard error with no health effect. lebh cols 1 and 2 is same with health effect.
cap drop lambdah2
cap drop lambdal2
mat lambdah=lambdah'
mat lambdal=lambdal'
*svmat creates variables from matrices and numbers columns. Hence lambdal1 is value and lambdal2 is s,d,
svmat lambdah
svmat lambdal
svmat lebl	
svmat lebh
*sort ltla19nm
* lambdal1 is ev relative to England average. lambdal2 is s.d of ev. lebl1 is life expectancy at twenty lebl2 is s.e. of lfe exoectabcy. Second group is adjusted for health effects. 

*	replace ltla19nm="Kings_Lynn_and_West_Norfolk"
*}
mkmat  rb1 /*ub1 Vub1*/ lambdal1 lambdal2 lebl1 lebl2 rb2 /* ub2 Vub2 */ lambdah1 lambdah2 lebh1 lebh2, mat(RESULTSP) rownames(ltla19nm)
*mat list RESULTSP
*estout mat(RESULTSP)
matlist RESULTSP, cspec(o4& %25s & %6.0f & %6.2f & %6.2f &%6.1f & %6.2f  & %6.0f  & %6.2f & %6.2f & %6.1f & %6.2f &) rspec(&-&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&)
estout mat(RESULTSP, fmt(0 2 2 2 2 0 2 2 2 2)),    sty(tex)
estout mat(RESULTSP, fmt(0 2 2 2 2 0 2 2 2 2)) using "$output/tabkp6Aug.tex",   replace sty(tex)
*consterm is local consumption term in welfare calculation
*subtract population-weighted england averages from consumption and labour terms
exit
