* this programme implements the expressions in Appendix D working out the variance matrix of life years and the prevalence of good health. 
***see line 131. THE VARIANCES ARE DIVIDED BY 3 BECAUSE THE LIFE TABLES ARE AVERAGES OF 3 YEARS
**PROGRAMME "matricies for L and H prevalence" uses population data from 2015 only. See lines
*** 22-24 of that programme
matrix drop _all
scalar drop _all
*This programme calculated the variances of life expectancy for each LTLA using demographic data which are generated by "matrices for L and Health Prevalence from ONS dataLTLA27Mar2023.do"
*extra lines put in to resolve issue of Bucks nos VV57-59 set equal to VV56
clear all
set more off
set maxvar 32000, perm

global output "P:/Working/KlemowMeasure"
global matrix "P:/Working/KlemowMeasure/matrices"
matrix drop _all
	scalar drop _all
	use "$output/ltladatamen.dta", clear
	* read in demographic data calculated in "matrices for L and Health Prevalence.do"
	sort ltla19cd
*	merge 1:1 ltla19cd using "$output/ltladatawomen.dta" 
*women now done in separate part of programme after men and quite independently
*	drop _merge
*	replace utla19cd="E10000002" if utla19cd=="E06000060"
	*replace utla19cd="E10000034" if utla19cd==" "
*keep utla19cd utla19nm
*gen utlacod=_n
*USED TO GIVE LIST OF UTLAs in order from this programme
*save "$output/utlalist.dta", replace
*import excel "$output/hsletemplate.xls",  cellrange(d6:s26) first case(preserve) clear
do "$output/matout"
matrix ax=J(1,19,0.5)
matrix ax=0.1,ax
*ax is fraction of each period survivated by decedent
matrix x=J(1,17,5)
matrix x=1,4,x,9
***** DOES MEN
scalar k=1
*flist if _n==k
*replace lx=1 if _n==k
scalar kk=k+1
scalar N=_N
** CONSOLIDATE DATA INTO MATRICES
mkmat lx1 lx2 lx3 lx4 lx5 lx6 lx7 lx8 lx9 lx10 lx11 lx12 lx13 lx14 lx15 lx16 lx17 lx18 lx19 lx20, mat(lx)
mat lx=lx'
mkmat px1 px2 px3 px4 px5 px6 px7 px8 px9 px10 px11 px12 px13 px14 px15 px16 px17 px18 px19 px20, mat(px)
mat px=px'
mkmat  varqx1 varqx2 varqx3 varqx4 varqx5 varqx6 varqx7 varqx8 varqx9 varqx10 varqx11 varqx12 varqx13 varqx14 varqx15 varqx16 varqx17 varqx18 varqx19 varqx20, mat(varqx)
mat varqx=varqx'
mkmat Lx1 Lx2 Lx3 Lx4 Lx5 Lx6 Lx7 Lx8 Lx9 Lx10 Lx11 Lx12 Lx13 Lx14 Lx15 Lx16 Lx17 Lx18 Lx19 Lx20, mat(Lx)
mat Lx=Lx'
mkmat HP1 HP2 HP3 HP4 HP5 HP6 HP7 HP8 HP9 HP10 HP11 HP12 HP13 HP14 HP15 HP16 HP17 HP18 HP19 HP20, mat(HP)
*HP is GGH from ONS Mortality spreadsheet
gen ex20=1/mx20
*equation 17 of Appendix D2
gen varex20=varqx20/4
mkmat ex20
mkmat varex20
mat ex20=ex20'
mat varex20=varex20'
gen qdummy=.
forvalues rs=1/20{
	replace qdummy=uwb`rs'/deff`rs'^2
*note that design effect is squared in template spreadsheet ( see col AK of ONS template)
	gen varhx`rs'=	(HP`rs'*(1-HP`rs'))/qdummy
}
* generate variance of health prevalence using equation 14. This is not correlated across ages. 
mkmat varhx1 varhx2 varhx3 varhx4 varhx5 varhx6 varhx7 varhx8 varhx9 varhx10 varhx11 varhx12 varhx13 varhx14 varhx15 varhx16 varhx17 varhx18 varhx19 varhx20, mat(varhx)
mat varhx=varhx'
*mkmat varex
forvalues rr=1/315{
mat vl=J(20,1,0)    
mat Vl=vl
scalar rr=`rr'
* VV is variance of life years vector
*VH is variances of good health prevalence rate
mat VV`rr'=J(20,20,0)
******
mat VH`rr'=J(20,20,0)
******
*mat Vl=0*lx
*mat Vl[k,1]=0
mat VH`rr'[20,20]=varhx[20,`rr']
forvalues j=1/19{
mat VH`rr'[`j',`j']=varhx[`j',`rr']
if `j'>= k {/* calculate varaince of lx in Vl*/
    scalar j=`j'
	forvalues r=1/`j'{
	if `r'>=k {
	scalar r=`r'
	scalar p=varqx[r,rr]
mat Vl[j+1,1]=Vl[j+1,1]+varqx[r,rr]/px[r,rr]^2
}
	}
mat Vl[j+1,1]=Vl[j+1,1]*lx[j+1,rr]^2
}
}
* down to line 108 we calculate the variance matrix of Lx
mat VV`rr'[20,20]=varex20[1,rr]*lx[20,rr]^2+Vl[20,1]*ex20[1,rr]^2
* variance of life years in last period. Equation 21 in appendix D2
forvalues j=1/19{
    * equation 22 of appendix D2 does the covariances between each age band and the final age band
	if `j'>k-1{
mat VV`rr'[`j',20]=x[1,`j']*ex20[1,rr]*(ax[1,`j']*Vl[`j',1]*lx[20,rr]/lx[`j',rr]+(1-ax[1,`j'])*Vl[`j'+1,1]*lx[20,rr]/lx[`j'+1,rr])
mat VV`rr'[20,`j']=VV`rr'[`j',20]
scalar xx=x[1,`j']
scalar aj=ax[1,`j']
* equation 23 does the variances of the other diagonal items
mat VV`rr'[`j',`j']=xx^2*(Vl[`j',1]*(aj+(1-aj)*px[`j',rr])^2)+xx^2*(1-aj)^2*(lx[`j',rr]^2*varqx[`j',rr])


*VV[20,j] checked 
*VV[j,j] checked

scalar jl=`j'-1
* and equation 24 does the other off-diagonal items in VV. 
forvalues m=1/`j'{
    if `m'>=k & `m'<`j'{  /* was k*/
	    scalar m=`m'
		scalar j=`j'
*		scalar list m j
	    scalar xx=x[1,`m']*x[1,`j']
		scalar am=ax[1,`m']
		scalar aj=ax[1,`j']
*scalar list aj am 
		scalar s1=aj*am*Vl[`m',1]*lx[`j',rr]/lx[`m',rr]
		scalar s2=aj*(1-am)*Vl[`m'+1,1]*lx[`j',rr]/lx[`m'+1,rr]
		scalar s3=(1-aj)*am*Vl[`m',1]*lx[`j'+1,rr]/lx[`m',rr]
		scalar s4=(1-aj)*(1-am)*Vl[`m'+1,1]*lx[`j'+1,rr]/lx[`m'+1,rr]
*		scalar list s1 s2 s3 s4
		mat  VV`rr'[`m',`j']=xx*(s1+s2+s3+s4)
		mat VV`rr'[`j',`m']=VV`rr'[`m',`j']
	}
}			
	}
}
}
* fill in for Bucks
forvalues rr=57/59{
	mat VV`rr'=VV56
}
*divide VV by 3 because life tables are average for three years  VH is calculated using base figures provided by ONS
*export variance matrices
forvalues rr=1/315{
	mat VV`rr'=VV`rr'/3
	matout VV`rr' using "$matrix/VV`rr'", replace
	matout VH`rr' using "$matrix/VH`rr'", replace
}
* export lx, Lx and health prevalence (HP) as matrices
*file called lxx because lx gets over-written by Lx. Also applies to lxw
matout lx using "$matrix/lxx", replace
matout Lx using "$matrix/Lx", replace
matout HP using "$matrix/HP", replace

mat ee=J(1,20,1)
mat vex=ee*VV1*ee'
mat list vex
mat list VH315

*DO CALCULATIONS  FOR WOMEN. The logic is the same as for men. 
	scalar drop _all
	use "$output/ltladatawomen.dta", clear
matrix drop _all
matrix ax=J(1,19,0.5)
matrix ax=0.1,ax
matrix x=J(1,17,5)
matrix x=1,4,x,9

scalar k=1
*flist if _n==k
*replace lx=1 if _n==k
scalar kk=k+1
scalar N=_N
mkmat lxw1 lxw2 lxw3 lxw4 lxw5 lxw6 lxw7 lxw8 lxw9 lxw10 lxw11 lxw12 lxw13 lxw14 lxw15 lxw16 lxw17 lxw18 lxw19 lxw20, mat(lxw)
mat lxw=lxw'
mkmat pxw1 pxw2 pxw3 pxw4 pxw5 pxw6 pxw7 pxw8 pxw9 pxw10 pxw11 pxw12 pxw13 pxw14 pxw15 pxw16 pxw17 pxw18 pxw19 pxw20, mat(pxw)
mat pxw=pxw'
mkmat  varqxw1 varqxw2 varqxw3 varqxw4 varqxw5 varqxw6 varqxw7 varqxw8 varqxw9 varqxw10 varqxw11 varqxw12 varqxw13 varqxw14 varqxw15 varqxw16 varqxw17 varqxw18 varqxw19 varqxw20, mat(varqxw)
mat varqxw=varqxw'
mkmat Lxw1 Lxw2 Lxw3 Lxw4 Lxw5 Lxw6 Lxw7 Lxw8 Lxw9 Lxw10 Lxw11 Lxw12 Lxw13 Lxw14 Lxw15 Lxw16 Lxw17 Lxw18 Lxw19 Lxw20, mat(Lxw)
mat Lxw=Lxw'
mkmat HPw1 HPw2 HPw3 HPw4 HPw5 HPw6 HPw7 HPw8 HPw9 HPw10 HPw11 HPw12 HPw13 HPw14 HPw15 HPw16 HPw17 HPw18 HPw19 HPw20, mat(HPw)

cap drop exw20
gen exw20=1/mxw20
cap drop varexw20
gen varexw20=varqxw20/4
mkmat exw20
mkmat varexw20
mat exw20=exw20'
mat varexw20=varexw20'
gen qdummyw=.
forvalues rs=1/20{
	replace qdummyw=uwbw`rs'/deffw`rs'
gen varhxw`rs'=	(HPw`rs'*(1-HPw`rs'))/qdummyw^2
}
mkmat varhxw1 varhxw2 varhxw3 varhxw4 varhxw5 varhxw6 varhxw7 varhxw8 varhxw9 varhxw10 varhxw11 varhxw12 varhxw13 varhxw14 varhxw15 varhxw16 varhxw17 varhxw18 varhxw19 varhxw20, mat(varhxw)
mat varhxw=varhxw'

*mkmat varex
forvalues rr=1/315{
mat vlw=J(20,1,0)
mat Vlw=vlw
scalar rr=`rr'
mat VVw`rr'=J(20,20,0)
******
mat VHw`rr'=J(20,20,0)
******
*mat Vl=0*lx
*mat Vl[k,1]=0
mat VHw`rr'[20,20]=varhxw[20,`rr']

*mat Vl=0*lx
*mat Vl[k,1]=0
forvalues j=1/19{
mat VHw`rr'[`j',`j']=varhxw[`j',`rr']

if `j'>= k {
    scalar j=`j'
	forvalues r=1/`j'{
	if `r'>=k {
	scalar r=`r'
	scalar p=varqxw[r,rr]
mat Vlw[j+1,1]=Vlw[j+1,1]+varqxw[r,rr]/pxw[r,rr]^2
}
	}
mat Vlw[j+1,1]=Vlw[j+1,1]*lxw[j+1,rr]^2
}
}
mat VVw`rr'[20,20]=varexw20[1,rr]*lxw[20,rr]^2+Vlw[20,1]*exw20[1,rr]^2

forvalues j=1/19{
	if `j'>k-1{
mat VVw`rr'[`j',20]=x[1,`j']*exw20[1,rr]*(ax[1,`j']*Vlw[`j',1]*lxw[20,rr]/lxw[`j',rr]+(1-ax[1,`j'])*Vlw[`j'+1,1]*lxw[20,rr]/lxw[`j'+1,rr])
mat VVw`rr'[20,`j']=VVw`rr'[`j',20]
scalar xx=x[1,`j']
scalar aj=ax[1,`j']
mat VVw`rr'[`j',`j']=xx^2*(Vlw[`j',1]*(aj+(1-aj)*pxw[`j',rr])^2)+xx^2*(1-aj)^2*(lxw[`j',rr]^2*varqxw[`j',rr])


*VV[20,j] checked 
*VV[j,j] checked

scalar jl=`j'-1
forvalues m=1/`j'{
    if `m'>=k & `m'<`j'{  /* was k*/
	    scalar m=`m'
		scalar j=`j'
*		scalar list m j
	    scalar xx=x[1,`m']*x[1,`j']
		scalar am=ax[1,`m']
		scalar aj=ax[1,`j']
*scalar list aj am 
		scalar s1=aj*am*Vlw[`m',1]*lxw[`j',rr]/lxw[`m',rr]
		scalar s2=aj*(1-am)*Vlw[`m'+1,1]*lxw[`j',rr]/lxw[`m'+1,rr]
		scalar s3=(1-aj)*am*Vlw[`m',1]*lxw[`j'+1,rr]/lxw[`m',rr]
		scalar s4=(1-aj)*(1-am)*Vlw[`m'+1,1]*lxw[`j'+1,rr]/lxw[`m'+1,rr]
*		scalar list s1 s2 s3 s4
		mat  VVw`rr'[`m',`j']=xx*(s1+s2+s3+s4)
		mat VVw`rr'[`j',`m']=VVw`rr'[`m',`j']
	}
}			
	}
}
}


mat ee=J(1,20,1)
mat vwex=ee*VVw1*ee'
mat list vwex
forvalues rr=57/59{
	mat VVw`rr'=VVw56
}

forvalues rr=1/315{
		mat VVw`rr'=VVw`rr'/3

	matout VVw`rr' using "$matrix/VVw`rr'", replace
	matout VHw`rr' using "$matrix/VHw`rr'", replace

}
matout lxw using "$matrix/lxxw", replace
matout Lxw using "$matrix/Lxw", replace
matout HPw using "$matrix/HPw", replace

mat list VHw315
